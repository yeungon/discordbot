// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: students.sql

package db

import (
	"context"
	"database/sql"
)

const createStudent = `-- name: CreateStudent :one
INSERT INTO students (
    name, student_code, gender, dob, dob_format, class, class_code,
    ethnic, national_id, phone, email, province, address, notes
) VALUES (
    $1, $2, $3, $4, $5, $6, $7,
    $8, $9, $10, $11, $12, $13, $14
) RETURNING id, name, student_code, gender, dob, dob_format, class, class_code, ethnic, national_id, phone, email, province, address, notes, search_vector
`

type CreateStudentParams struct {
	Name        sql.NullString
	StudentCode sql.NullString
	Gender      sql.NullString
	Dob         sql.NullString
	DobFormat   sql.NullString
	Class       sql.NullString
	ClassCode   sql.NullString
	Ethnic      sql.NullString
	NationalID  sql.NullString
	Phone       sql.NullString
	Email       sql.NullString
	Province    sql.NullString
	Address     sql.NullString
	Notes       sql.NullString
}

// INSERT
func (q *Queries) CreateStudent(ctx context.Context, arg CreateStudentParams) (Student, error) {
	row := q.db.QueryRowContext(ctx, createStudent,
		arg.Name,
		arg.StudentCode,
		arg.Gender,
		arg.Dob,
		arg.DobFormat,
		arg.Class,
		arg.ClassCode,
		arg.Ethnic,
		arg.NationalID,
		arg.Phone,
		arg.Email,
		arg.Province,
		arg.Address,
		arg.Notes,
	)
	var i Student
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.StudentCode,
		&i.Gender,
		&i.Dob,
		&i.DobFormat,
		&i.Class,
		&i.ClassCode,
		&i.Ethnic,
		&i.NationalID,
		&i.Phone,
		&i.Email,
		&i.Province,
		&i.Address,
		&i.Notes,
		&i.SearchVector,
	)
	return i, err
}

const deleteStudent = `-- name: DeleteStudent :exec
DELETE FROM students WHERE id = $1
`

// DELETE
func (q *Queries) DeleteStudent(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteStudent, id)
	return err
}

const getStudentByID = `-- name: GetStudentByID :one
SELECT id, name, student_code, gender, dob, dob_format, class, class_code, ethnic, national_id, phone, email, province, address, notes, search_vector FROM students WHERE id = $1
`

// SELECT
func (q *Queries) GetStudentByID(ctx context.Context, id int32) (Student, error) {
	row := q.db.QueryRowContext(ctx, getStudentByID, id)
	var i Student
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.StudentCode,
		&i.Gender,
		&i.Dob,
		&i.DobFormat,
		&i.Class,
		&i.ClassCode,
		&i.Ethnic,
		&i.NationalID,
		&i.Phone,
		&i.Email,
		&i.Province,
		&i.Address,
		&i.Notes,
		&i.SearchVector,
	)
	return i, err
}

const getStudentByName = `-- name: GetStudentByName :one
SELECT id, name, student_code, gender, dob, dob_format, class, class_code, ethnic, national_id, phone, email, province, address, notes, search_vector FROM students WHERE name = $1
`

func (q *Queries) GetStudentByName(ctx context.Context, name sql.NullString) (Student, error) {
	row := q.db.QueryRowContext(ctx, getStudentByName, name)
	var i Student
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.StudentCode,
		&i.Gender,
		&i.Dob,
		&i.DobFormat,
		&i.Class,
		&i.ClassCode,
		&i.Ethnic,
		&i.NationalID,
		&i.Phone,
		&i.Email,
		&i.Province,
		&i.Address,
		&i.Notes,
		&i.SearchVector,
	)
	return i, err
}

const getStudentByStudentCode = `-- name: GetStudentByStudentCode :one
SELECT id, name, student_code, gender, dob, dob_format, class, class_code, ethnic, national_id, phone, email, province, address, notes, search_vector FROM students WHERE student_code = $1
`

func (q *Queries) GetStudentByStudentCode(ctx context.Context, studentCode sql.NullString) (Student, error) {
	row := q.db.QueryRowContext(ctx, getStudentByStudentCode, studentCode)
	var i Student
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.StudentCode,
		&i.Gender,
		&i.Dob,
		&i.DobFormat,
		&i.Class,
		&i.ClassCode,
		&i.Ethnic,
		&i.NationalID,
		&i.Phone,
		&i.Email,
		&i.Province,
		&i.Address,
		&i.Notes,
		&i.SearchVector,
	)
	return i, err
}

const listStudents = `-- name: ListStudents :many
SELECT id, name, student_code, gender, dob, dob_format, class, class_code, ethnic, national_id, phone, email, province, address, notes, search_vector FROM students ORDER BY id
`

func (q *Queries) ListStudents(ctx context.Context) ([]Student, error) {
	rows, err := q.db.QueryContext(ctx, listStudents)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Student
	for rows.Next() {
		var i Student
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.StudentCode,
			&i.Gender,
			&i.Dob,
			&i.DobFormat,
			&i.Class,
			&i.ClassCode,
			&i.Ethnic,
			&i.NationalID,
			&i.Phone,
			&i.Email,
			&i.Province,
			&i.Address,
			&i.Notes,
			&i.SearchVector,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStudentsPaginated = `-- name: ListStudentsPaginated :many
SELECT id, name, student_code, gender, dob, dob_format, class, class_code, ethnic, national_id, phone, email, province, address, notes, search_vector FROM students ORDER BY id LIMIT $1 OFFSET $2
`

type ListStudentsPaginatedParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) ListStudentsPaginated(ctx context.Context, arg ListStudentsPaginatedParams) ([]Student, error) {
	rows, err := q.db.QueryContext(ctx, listStudentsPaginated, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Student
	for rows.Next() {
		var i Student
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.StudentCode,
			&i.Gender,
			&i.Dob,
			&i.DobFormat,
			&i.Class,
			&i.ClassCode,
			&i.Ethnic,
			&i.NationalID,
			&i.Phone,
			&i.Email,
			&i.Province,
			&i.Address,
			&i.Notes,
			&i.SearchVector,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchStudents = `-- name: SearchStudents :many
SELECT id, name, student_code, gender, dob, dob_format, class, class_code, ethnic, national_id, phone, email, province, address, notes, search_vector FROM students WHERE search_vector @@ plainto_tsquery('simple', $1) ORDER BY id
`

func (q *Queries) SearchStudents(ctx context.Context, plaintoTsquery string) ([]Student, error) {
	rows, err := q.db.QueryContext(ctx, searchStudents, plaintoTsquery)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Student
	for rows.Next() {
		var i Student
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.StudentCode,
			&i.Gender,
			&i.Dob,
			&i.DobFormat,
			&i.Class,
			&i.ClassCode,
			&i.Ethnic,
			&i.NationalID,
			&i.Phone,
			&i.Email,
			&i.Province,
			&i.Address,
			&i.Notes,
			&i.SearchVector,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchStudentsByPhrase = `-- name: SearchStudentsByPhrase :many
SELECT id, name, student_code, gender, dob, dob_format, class, class_code, ethnic, national_id, phone, email, province, address, notes, search_vector FROM students
WHERE search_vector @@ phraseto_tsquery('simple', $1) ORDER BY id
`

func (q *Queries) SearchStudentsByPhrase(ctx context.Context, phrasetoTsquery string) ([]Student, error) {
	rows, err := q.db.QueryContext(ctx, searchStudentsByPhrase, phrasetoTsquery)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Student
	for rows.Next() {
		var i Student
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.StudentCode,
			&i.Gender,
			&i.Dob,
			&i.DobFormat,
			&i.Class,
			&i.ClassCode,
			&i.Ethnic,
			&i.NationalID,
			&i.Phone,
			&i.Email,
			&i.Province,
			&i.Address,
			&i.Notes,
			&i.SearchVector,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchStudentsFilteredPaginated = `-- name: SearchStudentsFilteredPaginated :many
SELECT id, name, student_code, gender, dob, dob_format, class, class_code, ethnic, national_id, phone, email, province, address, notes, search_vector
FROM students
WHERE
  ($1::text IS NULL OR class = $1) AND
  ($2::text IS NULL OR gender = $2) AND
  ($3::text IS NULL OR search_vector @@ plainto_tsquery('simple', $3))
ORDER BY id
LIMIT $4 OFFSET $5
`

type SearchStudentsFilteredPaginatedParams struct {
	Column1 string
	Column2 string
	Column3 string
	Limit   int32
	Offset  int32
}

func (q *Queries) SearchStudentsFilteredPaginated(ctx context.Context, arg SearchStudentsFilteredPaginatedParams) ([]Student, error) {
	rows, err := q.db.QueryContext(ctx, searchStudentsFilteredPaginated,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Student
	for rows.Next() {
		var i Student
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.StudentCode,
			&i.Gender,
			&i.Dob,
			&i.DobFormat,
			&i.Class,
			&i.ClassCode,
			&i.Ethnic,
			&i.NationalID,
			&i.Phone,
			&i.Email,
			&i.Province,
			&i.Address,
			&i.Notes,
			&i.SearchVector,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateStudent = `-- name: UpdateStudent :exec
UPDATE students
SET
    name = $2,
    student_code = $3,
    gender = $4,
    dob = $5,
    dob_format = $6,
    class = $7,
    class_code = $8,
    ethnic = $9,
    national_id = $10,
    phone = $11,
    email = $12,
    province = $13,
    address = $14,
    notes = $15
WHERE id = $1
`

type UpdateStudentParams struct {
	ID          int32
	Name        sql.NullString
	StudentCode sql.NullString
	Gender      sql.NullString
	Dob         sql.NullString
	DobFormat   sql.NullString
	Class       sql.NullString
	ClassCode   sql.NullString
	Ethnic      sql.NullString
	NationalID  sql.NullString
	Phone       sql.NullString
	Email       sql.NullString
	Province    sql.NullString
	Address     sql.NullString
	Notes       sql.NullString
}

// UPDATE
func (q *Queries) UpdateStudent(ctx context.Context, arg UpdateStudentParams) error {
	_, err := q.db.ExecContext(ctx, updateStudent,
		arg.ID,
		arg.Name,
		arg.StudentCode,
		arg.Gender,
		arg.Dob,
		arg.DobFormat,
		arg.Class,
		arg.ClassCode,
		arg.Ethnic,
		arg.NationalID,
		arg.Phone,
		arg.Email,
		arg.Province,
		arg.Address,
		arg.Notes,
	)
	return err
}
